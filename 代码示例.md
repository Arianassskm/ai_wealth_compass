1. 基础模型（Base Models）:

```python
# models/base.py
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, Integer, DateTime, Boolean
from datetime import datetime

Base = declarative_base()

class TimestampMixin:
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

class SoftDeleteMixin:
    is_deleted = Column(Boolean, default=False)
    deleted_at = Column(DateTime, nullable=True)
```

2. 用户相关模型:

```python
# models/user.py
from sqlalchemy import Column, Integer, String, Enum, ForeignKey, JSON
from sqlalchemy.orm import relationship

class User(Base, TimestampMixin, SoftDeleteMixin):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True)
    username = Column(String(50), unique=True, index=True)
    email = Column(String(100), unique=True, index=True)
    hashed_password = Column(String(200))
    status = Column(Enum('active', 'inactive', 'suspended'))
    user_type = Column(Enum('regular', 'premium', 'admin'))
    last_login = Column(DateTime)
    
    # 关联关系
    settings = relationship("UserSetting", back_populates="user")
    profile = relationship("UserProfile", back_populates="user")
    assets = relationship("Asset", back_populates="user")
    decisions = relationship("ConsumptionDecision", back_populates="user")

class UserSetting(Base, TimestampMixin):
    __tablename__ = "user_settings"

    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    preference_type = Column(String(50))
    preference_value = Column(JSON)
    
    user = relationship("User", back_populates="settings")
```

3. 生命阶段和人设模型:

```python
# models/lifecycle.py
class LifeStage(Base, TimestampMixin):
    __tablename__ = "life_stages"

    id = Column(Integer, primary_key=True)
    name = Column(String(50))
    characteristics = Column(JSON)
    default_config = Column(JSON)
    transition_period = Column(Boolean, default=False)
    
    personas = relationship("PersonaTemplate", back_populates="life_stage")

class PersonaTemplate(Base, TimestampMixin):
    __tablename__ = "persona_templates"

    id = Column(Integer, primary_key=True)
    stage_id = Column(Integer, ForeignKey("life_stages.id"))
    template_name = Column(String(100))
    default_settings = Column(JSON)
    applicable_conditions = Column(JSON)
    
    life_stage = relationship("LifeStage", back_populates="personas")
```

4. 资产管理模型:

```python
# models/asset.py
from sqlalchemy import Numeric

class Asset(Base, TimestampMixin):
    __tablename__ = "assets"

    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    asset_type = Column(Enum('cash', 'investment', 'property', 'other'))
    amount = Column(Numeric(15, 2))
    status = Column(Enum('active', 'frozen', 'pending'))
    evaluation_date = Column(DateTime)
    
    changes = relationship("AssetChange", back_populates="asset")
    user = relationship("User", back_populates="assets")

class AssetChange(Base, TimestampMixin):
    __tablename__ = "asset_changes"

    id = Column(Integer, primary_key=True)
    asset_id = Column(Integer, ForeignKey("assets.id"))
    change_type = Column(Enum('increase', 'decrease', 'adjustment'))
    change_amount = Column(Numeric(15, 2))
    change_reason = Column(String(200))
    
    asset = relationship("Asset", back_populates="changes")
```

5. 消费决策模型:

```python
# models/consumption.py
class ConsumptionDecision(Base, TimestampMixin):
    __tablename__ = "consumption_decisions"

    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    amount = Column(Numeric(15, 2))
    category = Column(String(50))
    decision_status = Column(Enum('pending', 'approved', 'rejected'))
    impact_assessment = Column(JSON)
    reference_factors = Column(JSON)
    
    equivalences = relationship("EquivalenceConversion", back_populates="decision")
    user = relationship("User", back_populates="decisions")

class EquivalenceConversion(Base, TimestampMixin):
    __tablename__ = "equivalence_conversions"

    id = Column(Integer, primary_key=True)
    decision_id = Column(Integer, ForeignKey("consumption_decisions.id"))
    conversion_type = Column(String(50))
    equivalent_value = Column(Numeric(15, 2))
    reference_unit = Column(String(50))
    
    decision = relationship("ConsumptionDecision", back_populates="equivalences")
```

6. 预警系统模型:

```python
# models/alert.py
class AlertRule(Base, TimestampMixin):
    __tablename__ = "alert_rules"

    id = Column(Integer, primary_key=True)
    rule_type = Column(String(50))
    threshold_value = Column(Numeric(15, 2))
    condition_expression = Column(String(500))
    action_type = Column(String(50))
    
    records = relationship("AlertRecord", back_populates="rule")

class AlertRecord(Base, TimestampMixin):
    __tablename__ = "alert_records"

    id = Column(Integer, primary_key=True)
    rule_id = Column(Integer, ForeignKey("alert_rules.id"))
    user_id = Column(Integer, ForeignKey("users.id"))
    trigger_time = Column(DateTime)
    alert_status = Column(Enum('active', 'acknowledged', 'resolved'))
    resolution_status = Column(String(50))
    
    rule = relationship("AlertRule", back_populates="records")
```

7. 游戏化系统模型:

```python
# models/gamification.py
class Achievement(Base, TimestampMixin):
    __tablename__ = "achievements"

    id = Column(Integer, primary_key=True)
    achievement_type = Column(String(50))
    conditions = Column(JSON)
    reward_type = Column(String(50))
    reward_value = Column(JSON)
    
    user_achievements = relationship("UserAchievement", back_populates="achievement")

class UserAchievement(Base, TimestampMixin):
    __tablename__ = "user_achievements"

    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    achievement_id = Column(Integer, ForeignKey("achievements.id"))
    progress = Column(Numeric(5, 2))  # 百分比
    completion_time = Column(DateTime, nullable=True)
    
    achievement = relationship("Achievement", back_populates="user_achievements")
```

这些模型定义包含了：
1. 基础的时间戳和软删除功能
2. 清晰的关系定义
3. 适当的字段类型选择
4. 必要的索引设置

